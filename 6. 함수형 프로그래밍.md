# 함수형 프로그래밍



## 1. 개념

1. 함수형 프로그래밍은 함수의 조합으로 작업을 수행함을 의미한다. 
2. 중요한 것은 이 작업이 이루어지는 동안 작업에 필요한 데이터와 상태는 변하지 않는다는 점이다.
3. 변할 수 있는 건 오로지 함수뿐이고 이 함수가 바로 연산의 대상이 된다.
4. 순수 함수(Pure Function) : 외부에 아무런 영향을 미치지 않는 함수. 재사용 가능
5. 고계 함수(Higher-order Function) : 함수를 하나의 값으로 간주하여 함수의 인자 혹은 반환값으로 사용할 수 있는 함수
6. 함수형 프로그래밍은 높은 수준의 모듈화가 가능하다
7. 반대 개념 : 명령형 프로그래밍(Imperative Programming) - C 언어로 구현한 방식





## 2. 자바스크립트에서의 함수형 프로그래밍



### 1. 가능한 이유

1. 일급 객체로서의 함수, 클로저

```
var f1 = function (input) {
  var result;
  /* 암호화 작업 수행 */
  result = 1;
  return result;
}

var f2 = function (input) {
  var result;
  /* 암호화 작업 수행 */
  result = 2;
  return result;
}

var f3 = function (input) {
  var result;
  /* 암호화 작업 수행 */
  result = 3;
  return result;
}

var get_encrypted = function (func) {
  var str = 'zzoon';
  
  return function () {
    return func.call(null, str);
  }
}

var encrypted_value = get_encrypted(f1)();
console.log(encrypted_value);
var encrypted_value = get_encrypted(f2)();
console.log(encrypted_value);
var encrypted_value = get_encrypted(f3)();
console.log(encrypted_value);
```

2. 함수의 인자로 함수를 넘기고, 결과로 함수를 반환할 수 있다. 
3. 게다가 변수 str 값이 영향을 받지 않게 하려고 클로저를 사용하였다.
4. get_encrypted() 함수에서 반환하는 익명 함수가 클로저이고  이 클로저에서 접근하는 변수 str은 외부에서 접근할 수 없으므로 클로저로 함수형 프로그래밍의 개념을 정확히 구현해낼 수 있다.



### 2. 배열의 각 원소 총합 구하기

1. 배열의 각 원소를 다른 방식으로 산술하여 결과값을 얻기 위해 함수형 프로그래밍을 이용해보자.

```
function reduce(func, arr, memo) {
  var len = arr.length, i = 0, accum = memo;
  
  for(; i < len; i++) {
    accum = func(accum, arr[i]);
  }
  
  return accum;
}
```

2. reduce() 함수의 인자로 들어가는 함수를 직접 정의해 보자.

```
var arr = [1, 2, 3, 4];

var sum = function (x, y) { return x + y; };
var multiply = function (x, y) { return x * y; };

console.log(reduce(sum, arr, 0));
console.log(reduce(sum, arr, 1));
```



### 3. 팩토리얼

1. 재귀 호출

```
function fact(num) {
  return num === 0 ? 1 : num * fact(num - 1);
}

console.log(fact(100));
```

2. 함수형 프로그래밍으로 성능을 고려하여 구현해보자.

```
var fact = function () {
  var cache = {'0': 1};
  var func = function (n) {
    var result = 0;
    
    if (typeof(cache[n]) === 'number') {
      result = cache[n];
    } else {
    	result = cache[n] = n * func(n - 1);
    }
    return result;
  }
  return func;
}();

console.log(fact(10));
console.log(fact(20));
```

3. fact는 cache에 접근할 수 있는 클로저를 반환 받는다. 클로저로 숨겨지는 cache에는 팩토리얼을 연산한 값을 저장하고 있다. 연산을 수행하는 과정에서 캐시에 저장된 값이 있으면 곧바로 그 값을 반환하는 방식이다. 
4. 이렇게 하면 한 번 연산된 값을 캐시에 저장하고 있으므로, 중복된 연산을 피하여 보다 나은 성능의 함수를 구현할 수 있다.



### 4. 메모이제이션 패턴(Memoization Pattern)

1. memoize : '계산 결과를 저장해 놓아 이후 다시 계산할 필요 없이 사용할 수 있게 한다는 컴퓨팅 용어'
2. 메모이제이션 패턴은 계산된 결과를 함수 프로퍼티값으로 담아 놓고 나중에 사용한다.

```
function Calculate(key, input, func) {
  Calculate.data = Calculate.data || {};
  
  if (!Calculate.data[key]) {
    var result;
    result = func(input);
    Calculate.data[key] = result;
  }
  
  return Calculate.data[key];
}

var result = Calculate(1, 5, function(input) {
  return input * input;
});

console.log(result);

result = Calculate(2, 5, function (input) {
  return input * input / 4;
});

console.log(result);

console.log(Calculate(1));
console.log(Calculate(2));
```

3. 보다 범용적인 방법으로 Function.prototype에 memoization() 함수를 집어 넣는다.

```
Function.prototype.memoization = function (key) {
  var arg = Array.prototype.slice.call( arguments, 1 );
  this.data = this.data || {};
  
  return this.data[key] !== undefined ?
  	this.data[key] : this.data[key] = this.apply(this, arg);
};

function myCalculate1(input) {
  return input * input;
}

function myCalculate2(input) {
  return input * input / 4;
}

myCalculate1.memoization(1, 5);
myCalculate1.memoization(2, 4);
myCalculate1.memoization(1, 6);
myCalculate1.memoization(2, 7);

console.log(myCalculate1.memoization(1), myCalculate1.data[1]);
console.log(myCalculate1.memoization(2), myCalculate1.data[2]);
console.log(myCalculate2.memoization(1), myCalculate1.data[1]);
console.log(myCalculate2.memoization(2), myCalculate1.data[2]);
```

4. 주의할 점은 한 번 값이 들어간 경우 계속 유지되므로 이를 초기화하는 방법 역시 제공되어야 한다. 



### 5. 피보나치 수열

1. 함수형 프로그래밍 방식

```
var fibo = function () {
  var cache = {'0' : 0, '1' : 1};
  
  var func = function (n) {
    if (typeof(cache[n]) === 'number') {
      result = cache[n];
    } else {
      result = cache[n] = func(n - 1) + func(n - 2);
    }
    return result;
  }
  return func;
}();

console.log(fibo(10));
```

2. 팩토리얼과 피보나치 수열을 계산하는 함수를 인자로 받는 함수를 만들어 보자.

```
var cacher = function (cache, func) {
  var calculate = function (n) {
    if (typeof(cache[n]) === 'number') {
      result = cache[n];
    } else {
      result = cache[n] = func(calculate, n);
    }
    return result;
  }
  return calculate;
};
```

```
var fact = caher({ '0': 1 }, function (func, n) {
  return n * func(n - 1);
});

var fibo = cacher({ '0': 0, '1': 1 }, function (func, n) {
  return func(n - 1) + func(n - 2);
});

console.log(fact(10));
console.log(fibo(10));
```

