# 자바스크립트의 핵심 개념

[TOC]

## 자바스크립트의 핵심 개념



#### 1. Object 

자바스크립트에서 null, undefined를 제외한 나머지는 모두 객체이다. 

#### 2. Function

함수는 일급 객체이다. 

#### 3. Prototype

모든 객체는 [[Prototype]] 링크를 가지고 있고, 이 링크는 프로토타입 객체를 가리킨다.

#### 4. Excution Context & Closure

자바스크립트는 자신만의 독특한 과정으로 실행 컨텍스트를 만들고 그 안에서 실행이 이루어진다. 이 실행 컨텍스트는 자신만의 유효 범위 Scope를 갖는데, 이 과정에서 클로저를 구현할 수 있다. 

#### 5. 객체지향 프로그래밍

프로토타입 체인과 클로저로 상속, 캡슐화, 정보 은닉을 구현한다.

#### 6. 함수형 프로그래밍

함수와 클로저로 높은 수준의 모듈화가 가능하다. 

#### 7. 단점

- 느슨한 타입 체크로 디버깅이 어렵다. 
- 전역 객체의 존재





## 자바스크립트 기본 문법

프로그래밍은 변수를 통해 값을 저장하고 참조하며 연산자로 값을 연산, 평가하고 조건문과 반복문에 의한 흐름제어로 데이터의 흐름을 제어하고 함수로 재사용이 가능한 구문의 집합을 만들며 객체, 배열 등으로 자료를 구조화하는 것이다 .



#### 1. 변수 

값이 저장된 메모리 공간의 주소를 가리키는 식별자

#### 2. 값, 리터럴

소스코드 안에서 직접 만들어낸 상수 값 자체를 말하며 값을 구성하는 최소 단위

#### 3. 데이터 타입

#### 4. 연산자

#### 5. 키워드

수행할 동작을 규정한 것

#### 6. 주석

#### 7. 문

리터럴, 연산자, 표현식, 키워드 등으로 구성

조건문, 반복문으로 Control Flow

#### 8. 식(값)

#### 9. 함수

#### 10. 객체

#### 11. 배열





## 변수 호이스팅



1. var 선언문이나 function 선언문, class 선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성

2. 자바스크립트는 모든 선언문이 선언되기 이전에 참조 가능하다. 

3. 변수 생성 단계

   가. 선언 단계 : 변수 객체에 변수를 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다. 

   나. 초기화 단계 : 변수 객체에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화 된다.

   다. 할당 단계 : undefined로 초기화된 변수에 실제값을 할당한다.

4. 자바스크립트의 변수는 함수 레벨 스코프로 의도하지 않는 변수의 전역화로 인해 문제 발생

5. ES6 let, const  키워드로 블록 레벨 스코프 사용 가능





## 스코프

스코프는 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙이다. 자바스크립트는 이 규칙대로 식별자를 찾는다. 



### 1. 스코프의 구분

​	가. 변수는 선언 위치(전역 또는 지역)에 의해 스코프를 가지게 된다. 즉 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역(자바스크립트의 경우 함수 내부)에서 선언된 변수는 지역 스코프를 갖는 지역 변수가 된다. 

​	나. 전역 스코프를 갖는 전역 변수는 전역(코드 어디서든지)에서 참조할 수 있다. 지역(함수 내부)에서 선언된 지역 변수는 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다.

 

### 2. 스코프의 특징

​	가. 자바스크립트는 **함수 레벨 스코프**(function-level scope)를 따른다. 

​	나. ES6에서 도입된  **let** keyword를 사용하면 블록레벨 스코프를 사용할 수 있다. 



### 3. 전역 스코프

​	가. var 키워드로 선언한 전역 변수는 전역 객체(Global Object) window의 프로퍼티이다. 

​	나. 전역 변수의 사용은 변수 이름이 중복될 수 있고 의도치 않은 재할당에 의한 사애 변화로 코드를 예측하기 어렵게 만드므로 사용을 억제하여야 한다.



### 4. 비 블록 레벨 스코프(Non block-level scope)

함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다할지라도 모두 전역 스코프를 갖게 된다. 따라서 변수 x는 전역 변수이다. 

```
if (true) {
	var x = 5;
}
console.log(x;)
```



### 5. 함수 레벨 스코프

```
var foo = function () {
	var a = 3, b = 5;
	
	var bar = function () {
		var b = 7, c = 11;
		a += b + c
	};
	bar();
};
```



### 6. 렉시컬 스코프

```
var x = 1;

function foo() {
	var x = 10;
	bar();
}
function bar() {
	console.log(x);
}

foo();
bar();
```

​	가. 프로그래밍 언어는 두가지 방식으로 함수의 상위 스코프를 결정한다. 

​		ㄱ. 동적 스코프(Dynamic scope) : 함수를 어디서 호츨하였는지

​		ㄴ. 렉시컬 스코프(Lexical scope) : 정적 스코프(Static scope), 함수를 어디서 선언하였는지

​	나. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스포프를 따른다. 



### 7. 전역 변수

​	가. 암묵적 전역 변수(Implicit global) : var 키워드를 생략한 변수는 암묵적으로 전역변수가 된다. 

​	나. 전역변수의 중복과 같은 무분별한 사용은 위험하다. 전역변수를 반드시 사용할 이유를 찾지 못한다면 지역변수를 사용하여야 한다. 변수의 범위인 스코프는 좁을수록 좋다.

​	다. 최소한의 전역변수의 사용 : 애플리케이션에서 전역변수 사용을 위해 다음과 같이 전역 변수 객체 하나를 만들어 사용하는 것이다. 

```
var MYAPP = {};

MYAPP.student = {
	name: 'Lee',
	gender: 'male'
};
console.log(MYAPP.student.name);
```

​	라. 즉시실행함수를 이용한 전역변수 사용 억제

```
(function () {
	var MYAPP = {};
	
	MYAPP.student = {
		name: 'Lee',
		gender: 'male'
	};
	console.log(MYAPP.student.name);
})();
console.log(MYAPP.student.name);
//Uncaught ReferenceError: MYAPP is not defined
```





## Strict mode



1. 적용 : `'use strict';` 를 전역 또는 함수 몸체의 선두에 추가한다. 

2. 전역에 적용한 strict mode는 스크립트 단위로 적용된다. 하지만 전역에 적용하는 것은 피하자.

3. 함수단위로 strict mode를 적용하는 것도 피하자. 

4. 따라서 strict mode는 즉시실행함수로 감싼 스크립트 단위로 적용하는 것이 바람직하다.

5. strict mode가 발생시키는 에러

   가. 선언하지 않는 변수, 즉 암묵적 전역 변수를 참조하면 ReferenceError가 발생한다.

   나. 변수, 함수, 매개변수의 삭제 (SyntaxError: Delete of an unqualified identifier in strict mode.)

   다. 매개변수 이름의 중복 : 중복된 함수 파라미터 이름을 사용하면 SyntaxError가 발생한다.

   라. width 문의 사용 : SyntaxError가 발생한다.

   마. 일반 함수의 this : 일반 함수를 호출하면 this에 undefined가 바인딩되고 에러는 발생하지 않는다. 

6. 브라우저 호완성 : IE9 이하는 지원하지 않는다. 

   